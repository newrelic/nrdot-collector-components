# Contributing

Contributions are always welcome. Before contributing please read the
[code of conduct](https://opensource.newrelic.com/code-of-conduct/) and [search the issue tracker](../../issues); your issue may have already been discussed or fixed in `main`. To contribute,
[fork](https://help.github.com/articles/fork-a-repo/) this repository, commit your changes, and [send a Pull Request](https://help.github.com/articles/using-pull-requests/).

Note that our [code of conduct](https://opensource.newrelic.com/code-of-conduct/) applies to all platforms and venues related to this project; please follow it in all your interactions with the project and its participants.

If you're planning on contributing a new feature or an otherwise complex contribution, we kindly ask you to start a conversation with the maintainer team by opening up a GitHub issue first.

## Code of Conduct

Please note that this project follows the [New Relic Open Source Code of Conduct](https://opensource.newrelic.com/code-of-conduct/). By participating in this project you agree to abide by its terms.

## Contributor License Agreement

Keep in mind that when you submit your Pull Request, you'll need to sign the CLA via the click-through using CLA-Assistant. If you'd like to execute our corporate CLA, or if you have any questions, please drop us an email at opensource@newrelic.com.

For more information about CLAs, please check out Alex Russell's excellent post,
["Why Do I Need to Sign This?"](https://infrequently.org/2008/06/why-do-i-need-to-sign-this/).

## Local Testing

To manually test your changes, follow these steps to build and run the contrib
Collector locally. Ensure that you execute these commands from the root of the 
repository:

1. Build the Collector:

  ```shell
  make nrdotcol
  ```

2. Run the nrdotcol Collector with a local configuration file:

  ```shell
  ./bin/nrdotcol_<os>_<arch> --config otel-config.yaml
  ```

  The actual name of the binary will depend on your platform. For example, on Linux x64, use `./bin/nrdotcol_linux_amd64`.

Replace `otel-config.yaml` with the appropriate configuration file as needed.

3. Verify that your changes are reflected in the contrib Collector's behavior by
   testing it against the provided configuration.

4. Lint your changes:

 - For the entire project:
  ```shell
  make golint
  ```

 - For specific components (e.g., nopreceiver ):
  ```shell
  cd receiver/nopreceiver/
  make lint
  ```

5. Run the unit tests:

 - Run tests for the whole project from the project root:
  ```shell
  make gotest
  ```
 - Alternatively, run tests for the affected components. For example, to run the nopreceiver tests:
  ```shell
  cd receiver/nopreceiver/
  make test
  ```

## Changelog

### Overview

There are two auto generated Changelogs for this repository:

- `CHANGELOG.md` is intended for users of the collector and lists changes that affect the behavior of the collector.
- `CHANGELOG-API.md` is intended for developers who are importing packages from the collector codebase.

They are autogenerated from `.yaml` files in the `./.chloggen` directory.

### Adding a Changelog Entry

1. Create an entry file using `make chlog-new`. This generates a file based on your current branch (e.g. `./.chloggen/my-branch.yaml`)
2. Fill in all fields in the new file
3. Run `make chlog-validate` to ensure the new file is valid
4. Commit and push the file

During the collector release process, all `./chloggen/*.yaml` files are transcribed into `CHANGELOG.md` and `CHANGELOG-API.md` and then deleted.

### When to add a Changelog Entry

Pull requests that contain user-facing changes will require a changelog entry. Keep in mind the following types of users:
1. Those who are consuming the telemetry exported from the collector
2. Those who are deploying or otherwise managing the collector or its configuration
3. Those who are depending on APIs exported from collector packages
4. Those who are contributing to the repository

Changes that affect the first two groups should be noted in `CHANGELOG.md`. Changes that affect the third or fourth groups should be noted in `CHANGELOG-API.md`.

If a changelog entry is not required, start your pull request title with `[chore]`, or ask a maintainer or approver will add the `Skip Changelog` label to the pull request.

**Examples**

Changelog entry required:
- Changes to the configuration of the collector or any component
- Changes to the telemetry emitted from and/or processed by the collector
- Changes to the prerequisites or assumptions for running a collector
- Changes to an API exported by a collector package
- Meaningful changes to the performance of the collector

Judgement call:
- Major changes to documentation
- Major changes to tests or test frameworks
- Changes to developer tooling in the repo

No changelog entry:
- Typical documentation updates
- Refactorings with no meaningful change in functionality
- Most changes to tests
- Chores, such as enabling linters, or minor changes to the CI process

## Feature Requests

Feature requests should be submitted in the [Issue tracker](../../issues), with a description of the expected behavior & use case, where they'll remain closed until sufficient interest, [e.g. :+1: reactions](https://help.github.com/articles/about-discussions-in-issues-and-pull-requests/), has been [shown by the community](../../issues?q=is%3Aissue+sort%3Areactions-%2B1-desc).
Before submitting an Issue, please search for similar ones in the
[closed issues](../../issues?q=is%3Aissue+is%3Aclosed).

## Pull Requests

Pull requests must pass all automated tests and must be reviewed by at least one maintaining engineer before being merged.

### Title guidelines

The title for your pull-request should contain the component type and name in brackets, plus a short statement for your
change. For instance:

    [processor/tailsampling] fix AND policy

### Description guidelines

When linking to an open issue, if your PR is meant to close said issue, please prefix your issue with one of the
following keywords: `Resolves`, `Fixes`, or `Closes`. More information on this functionality (and more keyword options) can be found
[here](https://docs.github.com/en/issues/tracking-your-work-with-issues/linking-a-pull-request-to-an-issue#linking-a-pull-request-to-an-issue-using-a-keyword).
This will automatically close the issue once your PR has been merged.


## Issue Triaging

See [issue-triaging.md](./issue-triaging.md) for more information on the issue triaging process.

### Adding Labels via Comments

In order to facilitate proper label usage and to empower Code Owners, you are able to add labels to issues via comments. To add a label through a comment, post a new comment on an issue starting with `/label`, followed by a space-separated list of your desired labels. Supported labels come from the table below, or correspond to a component defined in the [CODEOWNERS file](.github/CODEOWNERS).

The following general labels are supported:

| Label                     | Label in Comment          |
|---------------------------|---------------------------|
| `arm64`                   | `arm64`                   |
| `good first issue`        | `good-first-issue`        |
| `help wanted`             | `help-wanted`             |
| `discussion needed`       | `discussion-needed`       |
| `needs triage`            | `needs-triage`            |
| `os:mac`                  | `os:mac`                  |
| `os:windows`              | `os:windows`              |
| `waiting for author`      | `waiting-for-author`      |
| `waiting-for-code-owners` | `waiting-for-code-owners` |
| `bug`                     | `bug`                     |
| `priority:p0`             | `priority:p0`             |
| `priority:p1`             | `priority:p1`             |
| `priority:p2`             | `priority:p2`             |
| `priority:p3`             | `priority:p3`             |
| `Stale`                   | `stale`                   |
| `never stale`             | `never-stale`             |

To delete a label, prepend the label with `-`. Note that you must make a new comment to modify labels; you cannot edit an existing comment.

Example label comment:

```
/label receiver/prometheus help-wanted -exporter/prometheus
```

## Portable Code

In order to ensure compatibility with different operating systems, code should be portable. Below are some guidelines to follow when writing portable code:

* Avoid using platform-specific libraries, features etc. Please opt for portable multi-platform solutions. 

* Avoid hard-coding platform-specific values. Use environment variables or configuration files for storing platform-specific values.

    For example, avoid using hard-coded file path
    ```
    filePath := "C:\Users\Bob\Documents\sampleData.csv"
    ```

    Instead environment variable or configuration file can be used.
    ```
    filePath := os.Getenv("DATA_FILE_PATH")
    ```
    or
    ```
    filePath := Configuration.Get("data_file_path")
    ```

* Be mindful of 
  - Standard file systems and file paths such as forward slashes (/) instead of backward slashes (\\) in Windows. Use the [`path/filepath` package](https://pkg.go.dev/path/filepath) when working with filepaths. 
  - Consistent line ending formats such as Unix (LF) or Windows (CRLF).

* Test your implementation thoroughly on different platforms if possible and fix any issues. 

With above guidelines, you can write code that is more portable and easier to maintain across different platforms. 

## Adding New Components

All components in this repository are owned and maintained by New Relic internal teams. External contributors are welcome to propose new components or contribute to existing ones, but component ownership must be assigned to a New Relic team.

For detailed step-by-step instructions on adding new components (receivers, exporters, processors, extensions, or connectors), please see **[docs/ADDING_COMPONENTS.md](docs/ADDING_COMPONENTS.md)**.

### Quick Summary

Before adding a component:

1. **Open an issue** proposing the new component
2. **Identify a New Relic team** that will fully own and maintain the component, i.e. act as code owners. The [NRDOT Platform Team](https://github.com/orgs/newrelic/teams/otelcomm) helps new code owners to get onboarded and understand their new responsibilities going forward.
3. **Follow the detailed guide** in [docs/ADDING_COMPONENTS.md](docs/ADDING_COMPONENTS.md) which includes:
   - Quick reference checklist
   - Step-by-step implementation guide
   - Required files and structure
   - Test requirements (80%+ coverage)
   - Files to update (`versions.yaml`, builder configs)
   - Quality check commands
   - Common issues and solutions

Maintenance of components is the responsibility of the owning New Relic team. If a component is no longer maintained by its owning team, it may be excluded from the default build.

## Semantic Conventions compatibility

When introducing new metrics, attributes or entity attributes to components, ensure that
[Semantic Conventions' compatibility guidelines](https://github.com/open-telemetry/opentelemetry-collector/blob/main/docs/coding-guidelines.md#semantic-conventions-compatibility)
are taken into account.

## Adding metrics to existing receivers
Following these steps for contributing additional metrics to existing receivers.
 - Read instructions [here](https://github.com/open-telemetry/opentelemetry-collector/blob/main/CONTRIBUTING.md#fork) on how to
   fork, build and create PRs. The only difference is to change repository name from `opentelemetry-collector` to `opentelemetry-collector-contrib`
 - Edit `metadata.yaml` of your metrics receiver to add new metrics, e.g.: `redisreceiver/metadata.yaml`
 - To generate new metrics on top of this updated YAML file.
   - Run `cd receiver/redisreceiver`
   - Run `go generate ./...`
- Review the changed files and merge the changes into your forked repo.
- Create PR from Github web console following the instructions above.

## General Recommendations
Below are some recommendations that apply to typical components. These are not rigid rules and there are exceptions but
in general try to follow them.

- Avoid introducing batching, retries or worker pools directly on receivers and exporters. Typically, these are general
  cases that can be better handled via processors (that also can be reused by other receivers and exporters).
- When implementing exporters try to leverage the exporter helpers from the core repo, see [exporterhelper
  package](https://github.com/open-telemetry/opentelemetry-collector/tree/main/exporter/exporterhelper). This will
  ensure that the exporter provides [zPages](https://opencensus.io/zpages/) and a standard set of metrics.
- `replace` statements in `go.mod` files can be automatically inserted by running `make crosslink`. For more information
  on the `crosslink` tool see the README [here](https://github.com/open-telemetry/opentelemetry-go-build-tools/tree/main/crosslink).

## Membership, Roles, and Responsibilities

### Code Ownership

All components in this repository are owned by New Relic internal teams. Code Owners are New Relic employees responsible for a component within this repository, as indicated by the [CODEOWNERS file](https://github.com/newrelic/nrdot-collector-components/blob/main/.github/CODEOWNERS). That responsibility includes development and testing of the core functionality, maintaining the component, triaging and responding to issues, and reviewing pull requests.

### Becoming a Code Owner (New Relic Employees)

If you are a New Relic employee and would like to become a Code Owner for a component, you should:

1. Demonstrate understanding of the component through contributions and reviews
2. Coordinate with your team and existing Code Owners
3. Open a PR with the following changes:
   - Add your GitHub username to the active codeowners entry in the component's `metadata.yaml` file
   - Run `make update-codeowners` to regenerate the CODEOWNERS file
   - Run `make generate` to update the component's README header

Be sure to tag the existing Code Owners within the PR to ensure they receive a notification.

### External Contributors

External contributors are welcome and encouraged to contribute to this repository! While component ownership is limited to New Relic internal teams, we greatly appreciate:
- Bug fixes and improvements to existing components
- Documentation enhancements
- Test coverage improvements
- Feature suggestions and bug reports

All contributions require review and approval from the component's Code Owners or repository maintainers.

## Makefile Guidelines

When adding or modifying the `Makefile`'s in this repository, consider the following design guidelines.

Make targets are organized according to whether they apply to the entire repository, or only to an individual module.
The [Makefile](./Makefile) SHOULD contain "repo-level" targets. (i.e. targets that apply to the entire repo.)
Likewise, `Makefile.Common` SHOULD contain "module-level" targets. (i.e. targets that apply to one module at a time.)
Each module should have a `Makefile` at its root that includes `Makefile.Common`.

### Module-level targets

Module-level targets SHOULD NOT act on nested modules. For example, running `make lint` at the root of the repo will
*only* evaluate code that is part of the `go.opentelemetry.io/collector` module. This excludes nested modules such as
`go.opentelemetry.io/collector/component`.

Each module-level target SHOULD have a corresponding repo-level target. For example, `make golint` will run `make lint`
in each module. In this way, the entire repository is covered. The root `Makefile` contains some "for each module" targets
that can wrap a module-level target into a repo-level target.

### Repo-level targets

Whenever reasonable, targets SHOULD be implemented as module-level targets (and wrapped with a repo-level target).
However, there are many valid justifications for implementing a standalone repo-level target.

1. The target naturally applies to the repo as a whole. (e.g. Building the collector.)
2. Interaction between modules would be problematic.
3. A necessary tool does not provide a mechanism for scoping its application. (e.g. `porto` cannot be limited to a specific module.)
4. The "for each module" pattern would result in incomplete coverage of the codebase. (e.g. A target that scans all file, not just `.go` files.)

### Default targets

The default module-level target (i.e. running `make` in the context of an individual module), should run a substantial set of module-level
targets for an individual module. Ideally, this would include *all* module-level targets, but exceptions should be made if a particular
target would result in unacceptable latency in the local development loop.

The default repo-level target (i.e. running `make` at the root of the repo) should meaningfully validate the entire repo. This should include
running the default common target for each module as well as additional repo-level targets.
